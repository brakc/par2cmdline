--- par2cmdline-0.4/par1fileformat.h.orig	2003-08-01 23:42:21.000000000 +0000
+++ par2cmdline-0.4/par1fileformat.h	2005-11-04 10:37:10.725606960 +0000
@@ -31,7 +31,7 @@
 #pragma warning(disable:4200)
 #endif
 
-struct PAR1MAGIC {u8 magic[8];}PACKED;
+struct PAR1MAGIC {u8 magic[8];};
 
 struct PAR1FILEHEADER
 {
@@ -46,7 +46,7 @@
   leu64       filelistsize;
   leu64       dataoffset;
   leu64       datasize;
-}PACKED;
+};
 
 struct PAR1FILEENTRY
 {
@@ -56,7 +56,7 @@
   MD5Hash     hashfull;
   MD5Hash     hash16k;
   leu16       name[];
-}PACKED;
+};
 
 enum FILEENTRYSTATUS
 {
--- par2cmdline-0.4/par2fileformat.h.orig	2003-08-01 23:43:40.000000000 +0000
+++ par2cmdline-0.4/par2fileformat.h	2005-11-04 10:36:03.149880032 +0000
@@ -63,11 +63,11 @@
 {
   // Header
   MAGIC            magic;  // = {'P', 'A', 'R', '2', '\0', 'P', 'K', 'T'}
-  leu64            length; // Length of entire packet including header
+  leu64            length PACKED; // Length of entire packet including header
   MD5Hash          hash;   // Hash of entire packet excepting the first 3 fields
   MD5Hash          setid;  // Normally computed as the Hash of body of "Main Packet"
   PACKETTYPE       type;   // Used to specify the meaning of the rest of the packet
-} PACKED;
+};
 
 // The file verification packet is used to determine whether or not any
 // parts of a damaged file are useable.
@@ -78,14 +78,14 @@
 {
   MD5Hash        hash;
   leu32          crc;
-} PACKED;
+};
 struct FILEVERIFICATIONPACKET
 {
   PACKET_HEADER         header;
   // Body
   MD5Hash               fileid;     // MD5hash of file_hash_16k, file_length, file_name
   FILEVERIFICATIONENTRY entries[];
-} PACKED;
+};
 
 // The file description packet is used to record the name of the file,
 // its size, and the Hash of both the whole file and the first 16k of
@@ -110,7 +110,7 @@
 
   //u8* name(void) {return (u8*)&this[1];}
   //const u8* name(void) const {return (const u8*)&this[1];}
-} PACKED;
+};
 
 // The main packet is used to tie together the other packets in a recovery file.
 // It specifies the block size used to virtually slice the source files, a count
@@ -126,12 +126,12 @@
 {
   PACKET_HEADER    header;
   // Body
-  leu64            blocksize;
+  leu64            blocksize PACKED;
   leu32            recoverablefilecount;
   MD5Hash          fileid[0];
   //MD5Hash* fileid(void) {return (MD5Hash*)&this[1];}
   //const MD5Hash* fileid(void) const {return (const MD5Hash*)&this[1];}
-} PACKED;
+};
 
 // The creator packet is used to identify which program created a particular
 // recovery file. It is not required for verification or recovery of damaged
@@ -142,7 +142,7 @@
   // Body
   u8               client[];
   //u8* client(void) {return (u8*)&this[1];}
-} PACKED;
+};
 
 // The recovery block packet contains a single block of recovery data along
 // with the exponent value used during the computation of that block.
@@ -153,7 +153,7 @@
   leu32            exponent;
 //  unsigned long    data[];
 //  unsigned long* data(void) {return (unsigned long*)&this[1];}
-} PACKED;
+};
 
 #ifdef _MSC_VER
 #pragma warning(default:4200)
--- par2cmdline-0.4/reedsolomon.cpp.orig	2003-05-26 18:01:31.000000000 +0000
+++ par2cmdline-0.4/reedsolomon.cpp	2005-11-04 10:40:23.855246792 +0000
@@ -51,6 +51,7 @@
   }
 }
 
+template <>
 bool ReedSolomon<Galois8>::SetInput(const vector<bool> &present)
 {
   inputcount = (u32)present.size();
@@ -80,6 +81,7 @@
   return true;
 }
 
+template <>
 bool ReedSolomon<Galois8>::SetInput(u32 count)
 {
   inputcount = count;
@@ -101,6 +103,7 @@
   return true;
 }
 
+template <>
 bool ReedSolomon<Galois8>::Process(size_t size, u32 inputindex, const void *inputbuffer, u32 outputindex, void *outputbuffer)
 {
   // Look up the appropriate element in the RS matrix
@@ -189,6 +192,7 @@
 
 // Set which of the source files are present and which are missing
 // and compute the base values to use for the vandermonde matrix.
+template <>
 bool ReedSolomon<Galois16>::SetInput(const vector<bool> &present)
 {
   inputcount = (u32)present.size();
@@ -233,6 +237,7 @@
 
 // Record that the specified number of source files are all present
 // and compute the base values to use for the vandermonde matrix.
+template <>
 bool ReedSolomon<Galois16>::SetInput(u32 count)
 {
   inputcount = count;
@@ -267,6 +272,7 @@
   return true;
 }
 
+template <>
 bool ReedSolomon<Galois16>::Process(size_t size, u32 inputindex, const void *inputbuffer, u32 outputindex, void *outputbuffer)
 {
   // Look up the appropriate element in the RS matrix
